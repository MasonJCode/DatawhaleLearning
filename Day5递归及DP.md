## 递归及DP

### 一、递归

+ 递归的例子：从前有座山，山里有座庙，庙里有个老和尚，老和尚再讲故事，从前有座山，山里有座庙，庙里有个老和尚......

+ 上面那个例子就是递归，简单来说，递归就时函数调用自身。

+ 递归算法解决问题的特点：   

  1. 递归就是方法里调用自身。   
  2. 在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。                 
  3. 递归算法解题通常显得很简洁，但递归算法解题的运行效率较低。所以一般不提倡用递归算法设计程序。
  4. 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。

+ 经典递归的例子斐波那契数列（[什么是斐波那契数列](https://baijiahao.baidu.com/s?id=1606651492697783298&wfr=spider&for=pc)）

  Java用递归方式实现斐波那契数列：

  ```Java
  public static int Fibonacci(int n){
      if(n==1||n==2){
          return 1;
      }else{
          return Fibonacci(n-2)+Fibonacci(n-1);
      }
  }
  ```

  

### 二、动态规划

+ **动态规划**就是把原问题分解为相对简单的子问题的方式求解复杂问题的方法

+ **步骤：**

  1、描述最优解的结构

  2、递归定义最优解的值

  3、按自底向上的方式计算最优解的值

  4、由计算出的结果构造一个最优解

+ **分治与动态规划**

  + <font color="red">分治</font>的基本思想：分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

  + 分治法所适用情况：

    分治法所能解决的问题一般具有以下几个特征：

    ​    1) 该问题的规模缩小到一定的程度就可以容易地解决

    ​    2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

    ​    3) 利用该问题分解出的子问题的解可以合并为该问题的解；

    ​    4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

  + 基本步骤：分治法在每一层递归上都有三个步骤：

    ​    step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

    ​    step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

    ​    step3 合并：将各个子问题的解合并为原问题的解。

  + <font color="red">与动态规划的异同</font>

    **共同点**：二者都要求原问题具有最优子结构性质,都是将原问题分而治之,

    分解成若干个规模较小(小到很容易解决的程序)的子问题。

    然后将子问题的解合并,形成原问题的解。

    **不同点：**分治法将分解后的子问题看成相互独立的，通过用递归来做。

    动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做。

+ 动态规划之背包问题

  **题目：**假设现有容量10kg的背包，另外有3个物品，分别为a1，a2，a3。物品a1重量为3kg，

  价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6。

  将哪些物品放入背包可使得背包中的总价值最大？

  ```java
  public class BackPack {
      public static void main(String[] args) {
          int m = 10;
          int n = 3;
          int w[] = {3, 4, 5};
          int p[] = {4, 5, 6};
          int c[][] = BackPack_Solution(m, n, w, p);
          for (int i = 1; i <=n; i++) {
              for (int j = 1; j <=m; j++) {
                  System.out.print(c[i][j]+"\t");
                  if(j==m){
                      System.out.println();
                  }
              }
          }
          //printPack(c, w, m, n);
  
      }
  
   /**
       * @param m 表示背包的最大容量
       * @param n 表示商品个数
       * @param w 表示商品重量数组
       * @param p 表示商品价值数组
       */
      public static int[][] BackPack_Solution(int m, int n, int[] w, int[] p) {
          //c[i][v]表示前i件物品恰放入一个重量为m的背包可以获得的最大价值
          int c[][] = new int[n + 1][m + 1];
          for (int i = 0; i < n + 1; i++)
              c[i][0] = 0;
          for (int j = 0; j < m + 1; j++)
              c[0][j] = 0;
  
          for (int i = 1; i < n + 1; i++) {
              for (int j = 1; j < m + 1; j++) {
                  //当物品为i件重量为j时，如果第i件的重量(w[i-1])小于重量j时，c[i][j]为下列两种情况之一：
                  //(1)物品i不放入背包中，所以c[i][j]为c[i-1][j]的值
                  //(2)物品i放入背包中，则背包剩余重量为j-w[i-1],所以c[i][j]为c[i-1][j-w[i-1]]的值加上当前物品i的价值
                  if (w[i - 1] <= j) {
                      if (c[i - 1][j] < (c[i - 1][j - w[i - 1]] + p[i - 1]))
                          c[i][j] = c[i - 1][j - w[i - 1]] + p[i - 1];
                      else
                          c[i][j] = c[i - 1][j];
                  } else
                      c[i][j] = c[i - 1][j];
              }
          }
          return c;
      }
  ```

  

### 三、参考链接

大话数据结构

算法图解

[Pushy-博客园](https://www.cnblogs.com/Pushy/p/8455862.html)

[GGBeng](https://www.cnblogs.com/xzxl/p/7364515.html)

[xiaomingtx](https://www.cnblogs.com/xiaomingtx/p/5760973.html)

[什么是动态规划](https://baijiahao.baidu.com/s?id=1570689459307346&wfr=spider&for=pc)

[王小北-博客园](https://www.cnblogs.com/raichen/p/5772056.html)

[qq_20309055的csdn博客](https://blog.csdn.net/qq_20309055/article/details/78877909)

[动态规划之背包问题-凌风1205的博客](https://www.cnblogs.com/lfeng1205/p/5981198.html)